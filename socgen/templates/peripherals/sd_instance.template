{% block sd_instance scoped %}

wire       sd_data_busy, data_crc_ok, sd_dat_oe;
wire [3:0] sd_dat_to_mem, sd_dat_to_host, sd_dat_to_host_maj;
wire       sd_cmd_to_mem, sd_cmd_to_host, sd_cmd_to_host_maj, sd_cmd_oe;
wire       sd_clk_o;
wire       sd_cmd_finish, sd_data_finish, sd_cmd_crc_ok, sd_cmd_index_ok;

reg  [2:0] sd_data_start_reg;
reg  [1:0] sd_align_reg;
reg [15:0] sd_blkcnt_reg;
reg [11:0] sd_blksize_reg;

reg [15:0] clock_divider_sd_clk_reg;
reg  [2:0] sd_cmd_setting_reg;
reg  [5:0] sd_cmd_i_reg;
reg [31:0] sd_cmd_arg_reg;
reg [31:0] sd_cmd_timeout_reg;

reg sd_cmd_start_reg;

reg  [2:0] sd_data_start;
reg  [1:0] sd_align;
reg [15:0] sd_blkcnt;
reg [11:0] sd_blksize;

reg [15:0] clock_divider_sd_clk;
reg  [2:0] sd_cmd_setting;
reg  [5:0] sd_cmd_i;
reg [31:0] sd_cmd_arg;
reg [31:0] sd_cmd_timeout;

reg 	     sd_cmd_start, sd_cmd_rst, sd_data_rst, sd_clk_rst;

logic  [6:0] sd_clk_daddr;
logic        sd_clk_dclk, sd_clk_den, sd_clk_drdy, sd_clk_dwe, sd_clk_locked;
logic [15:0] sd_clk_din, sd_clk_dout;

wire tx_rd_fifo;
wire rx_wr_fifo;

assign one_hot_rdata[{{per.memory_region + 1}}] = sd_status_reg; // legacy setting
assign one_hot_rdata[{{per.memory_region + 2}}] = sd_cmd_resp_sel;

always @(posedge sd_clk_o) begin
  sd_align <= sd_align_reg;
  sd_cmd_arg <= sd_cmd_arg_reg;
  sd_cmd_i <= sd_cmd_i_reg;
  {sd_data_start,sd_cmd_setting} <= {sd_data_start_reg,sd_cmd_setting_reg};
  sd_cmd_start <= sd_cmd_start_reg;
  sd_blkcnt <= sd_blkcnt_reg;
  sd_blksize <= sd_blksize_reg;
  sd_cmd_timeout <= sd_cmd_timeout_reg;
end

//Tx Fifo
wire [31:0] data_in_rx_fifo;
wire        tx_almostfull, tx_full, tx_rderr, tx_wrerr, tx_empty;
wire [11:0] tx_wrcount, tx_rdcount;
//Rx Fifo
wire [31:0] data_out_tx_fifo;
wire        rx_almostfull, rx_full, rx_rderr, rx_wrerr, rx_empty;
wire [11:0] rx_wrcount, rx_rdcount;
wire data_rst = ~(sd_data_rst&rstn);

parameter iostd = "LVTTL";
parameter slew = "FAST";
parameter iodrv = 24;
// tri-state gate
IOBUF #(
    .DRIVE(iodrv), // Specify the output drive strength
    .IBUF_LOW_PWR("FALSE"),  // Low Power - "TRUE", High Performance = "FALSE"
    .IOSTANDARD(iostd), // Specify the I/O standard
    .SLEW(slew) // Specify the output slew rate
 ) IOBUF_cmd_inst (
    .O(sd_cmd_to_host),     // Buffer output
    .IO(sd_cmd),   // Buffer inout port (connect directly to top-level port)
    .I(sd_cmd_to_mem),     // Buffer input
    .T(~sd_cmd_oe)      // 3-state enable input, high=input, low=output
 );

 rx_delay cmd_rx_dly(
     .clk(clk_200MHz),
     .in(sd_cmd_to_host),
     .maj(sd_cmd_to_host_maj));

IOBUF #(
     .DRIVE(iodrv), // Specify the output drive strength
     .IBUF_LOW_PWR("FALSE"),  // Low Power - "TRUE", High Performance = "FALSE"
     .IOSTANDARD(iostd), // Specify the I/O standard
     .SLEW(slew) // Specify the output slew rate
  ) IOBUF_clk_inst (
     .O(),     // Buffer output
     .IO(sd_sclk),   // Buffer inout port (connect directly to top-level port)
     .I(~sd_clk_o),     // Buffer input
     .T(~sd_clk_rst)      // 3-state enable input, high=input, low=output
);

 genvar sd_dat_ix;
 generate for (sd_dat_ix = 0; sd_dat_ix < 4; sd_dat_ix=sd_dat_ix+1)
     begin
      IOBUF #(
        .DRIVE(iodrv), // Specify the output drive strength
         .IBUF_LOW_PWR("FALSE"),  // Low Power - "TRUE", High Performance = "FALSE"
         .IOSTANDARD(iostd), // Specify the I/O standard
         .SLEW(slew) // Specify the output slew rate
     ) IOBUF_dat_inst (
         .O(sd_dat_to_host[sd_dat_ix]),     // Buffer output
         .IO(sd_dat[sd_dat_ix]),   // Buffer inout port (connect directly to top-level port)
         .I(sd_dat_to_mem[sd_dat_ix]),     // Buffer input
         .T(~sd_dat_oe)      // 3-state enable input, high=input, low=output
     );
     rx_delay dat_rx_dly(
         .clk(clk_200MHz),
         .in(sd_dat_to_host[sd_dat_ix]),
         .maj(sd_dat_to_host_maj[sd_dat_ix]));
     end

endgenerate

my_fifo #(.width(36)) tx_fifo (
.rd_clk(~sd_clk_o),      // input wire read clk
.wr_clk(~msoc_clk),      // input wire write clk
.rst(data_rst),      // input wire rst
.din({dummy[3:0],core_lsu_wdata}),      // input wire [31 : 0] din
.wr_en(core_lsu_req&core_lsu_we&one_hot_data_addr[5]),  // input wire wr_en
.rd_en(tx_rd_fifo),  // input wire rd_en
.dout({dummy[7:4],data_out_tx_fifo}),    // output wire [31 : 0] dout
.rdcount(tx_rdcount),         // 12-bit output: Read count
.rderr(tx_rderr),             // 1-bit output: Read error
.wrcount(tx_wrcount),         // 12-bit output: Write count
.wrerr(tx_wrerr),             // 1-bit output: Write error
.almostfull(tx_almostfull),   // output wire almost full
.full(tx_full),    // output wire full
.empty(tx_empty)  // output wire empty
);

my_fifo #(.width(36)) rx_fifo (
.rd_clk(~msoc_clk),      // input wire read clk
.wr_clk(sd_clk_o),      // input wire write clk
.rst(data_rst),      // input wire rst
.din({dummy[11:8],data_in_rx_fifo}),      // input wire [31 : 0] din
.wr_en(rx_wr_fifo),  // input wire wr_en
.rd_en(core_lsu_req&core_lsu_we&one_hot_data_addr[4]),  // input wire rd_en
.dout({dummy[15:12],one_hot_rdata[{{per.memory_region}}]}),    // output wire [31 : 0] dout
.rdcount(rx_rdcount),         // 12-bit output: Read count
.rderr(rx_rderr),             // 1-bit output: Read error
.wrcount(rx_wrcount),         // 12-bit output: Write count
.wrerr(rx_wrerr),             // 1-bit output: Write error
.almostfull(rx_almostfull),   // output wire almost full
.full(rx_full),    // output wire full
.empty(rx_empty)  // output wire empty
);

logic [133:0] sd_cmd_response, sd_cmd_response_reg;
logic  [31:0] sd_cmd_resp_sel, sd_status_reg;
logic  [31:0] sd_status, sd_cmd_wait, sd_data_wait, sd_cmd_wait_reg, sd_data_wait_reg;
logic   [6:0] sd_cmd_crc_val;
logic  [47:0] sd_cmd_packet, sd_cmd_packet_reg;
logic  [15:0] sd_transf_cnt, sd_transf_cnt_reg;
logic         sd_detect_reg;

wire [31:0]  rx_fifo_status = {rx_almostfull,rx_full,rx_rderr,rx_wrerr,rx_rdcount,rx_wrcount};
wire [31:0]  tx_fifo_status = {tx_almostfull,tx_full,tx_rderr,tx_wrerr,tx_rdcount,tx_wrcount};

always @(posedge msoc_clk)
  begin
  sd_status_reg = sd_status;
  sd_cmd_response_reg = sd_cmd_response;
  sd_cmd_wait_reg = sd_cmd_wait;
  sd_data_wait_reg = sd_data_wait;
  sd_cmd_packet_reg = sd_cmd_packet;
  sd_transf_cnt_reg = sd_transf_cnt;
  case(core_lsu_addr[6:2])
    0: sd_cmd_resp_sel = sd_cmd_response_reg[38:7];
    1: sd_cmd_resp_sel = sd_cmd_response_reg[70:39];
    2: sd_cmd_resp_sel = sd_cmd_response_reg[102:71];
    3: sd_cmd_resp_sel = sd_cmd_response_reg[133:103];
    4: sd_cmd_resp_sel = sd_cmd_wait_reg;
    5: sd_cmd_resp_sel = sd_status_reg;
    6: sd_cmd_resp_sel = sd_cmd_packet_reg[31:0];
    7: sd_cmd_resp_sel = sd_cmd_packet_reg[47:32];
    8: sd_cmd_resp_sel = sd_data_wait_reg;
    9: sd_cmd_resp_sel = sd_transf_cnt_reg;
   10: sd_cmd_resp_sel = rx_fifo_status;
   11: sd_cmd_resp_sel = tx_fifo_status;
   12: sd_cmd_resp_sel = sd_detect_reg;
   15: sd_cmd_resp_sel = {sd_clk_locked,sd_clk_drdy,sd_clk_dout};
   16: sd_cmd_resp_sel = sd_align_reg;
   17: sd_cmd_resp_sel = sd_clk_din;
   18: sd_cmd_resp_sel = sd_cmd_arg_reg;
   19: sd_cmd_resp_sel = sd_cmd_i_reg;
   20: sd_cmd_resp_sel = {sd_data_start_reg,sd_cmd_setting_reg};
   21: sd_cmd_resp_sel = sd_cmd_start_reg;
   22: sd_cmd_resp_sel = {sd_reset,sd_clk_rst,sd_data_rst,sd_cmd_rst};
   23: sd_cmd_resp_sel = sd_blkcnt_reg;
   24: sd_cmd_resp_sel = sd_blksize_reg;
   25: sd_cmd_resp_sel = sd_cmd_timeout_reg;
   26: sd_cmd_resp_sel = {sd_clk_dwe,sd_clk_den,sd_clk_daddr};
  default: sd_cmd_resp_sel = 32'HDEADBEEF;
  endcase // case (core_lsu_addr[6:2])
  end

assign sd_status[3:0] = {tx_full,tx_empty,rx_full,rx_empty};

clk_wiz_1 sd_clk_div
  (
  // Clock in ports
   .clk_in1(msoc_clk),      // input clk_in1
   // Clock out ports
   .clk_sdclk(sd_clk_o),     // output clk_sdclk
   // Dynamic reconfiguration ports
   .daddr(sd_clk_daddr), // input [6:0] daddr
   .dclk(sd_clk_dclk), // input dclk
   .den(sd_clk_den), // input den
   .din(sd_clk_din), // input [15:0] din
   .dout(sd_clk_dout), // output [15:0] dout
   .drdy(sd_clk_drdy), // output drdy
   .dwe(sd_clk_dwe), // input dwe
   // Status and control signals
   .reset(~(sd_clk_rst&rstn)), // input reset
   .locked(sd_clk_locked));      // output locked

sd_top sdtop(
 .sd_clk     (sd_clk_o),
 .cmd_rst    (~(sd_cmd_rst&rstn)),
 .data_rst   (data_rst),
 .setting_i  (sd_cmd_setting),
 .timeout_i  (sd_cmd_timeout),
 .cmd_i      (sd_cmd_i),
 .arg_i      (sd_cmd_arg),
 .start_i    (sd_cmd_start),
 .sd_data_start_i(sd_data_start),
 .sd_align_i(sd_align),
 .sd_blkcnt_i(sd_blkcnt),
 .sd_blksize_i(sd_blksize),
 .sd_data_i(data_out_tx_fifo),
 .sd_dat_to_host(sd_dat_to_host_maj),
 .sd_cmd_to_host(sd_cmd_to_host_maj),
 .finish_cmd_o(sd_cmd_finish),
 .finish_data_o(sd_data_finish),
 .response0_o(sd_cmd_response[38:7]),
 .response1_o(sd_cmd_response[70:39]),
 .response2_o(sd_cmd_response[102:71]),
 .response3_o(sd_cmd_response[133:103]),
 .crc_ok_o   (sd_cmd_crc_ok),
 .index_ok_o (sd_cmd_index_ok),
 .transf_cnt_o(sd_transf_cnt),
 .wait_o(sd_cmd_wait),
 .wait_data_o(sd_data_wait),
 .status_o(sd_status[31:4]),
 .packet0_o(sd_cmd_packet[31:0]),
 .packet1_o(sd_cmd_packet[47:32]),
 .crc_val_o(sd_cmd_crc_val),
 .crc_actual_o(sd_cmd_response[6:0]),
 .sd_rd_o(tx_rd_fifo),
 .sd_we_o(rx_wr_fifo),
 .sd_data_o(data_in_rx_fifo),
 .sd_dat_to_mem(sd_dat_to_mem),
 .sd_cmd_to_mem(sd_cmd_to_mem),
 .sd_dat_oe(sd_dat_oe),
 .sd_cmd_oe(sd_cmd_oe)
 );

{% endblock %}
